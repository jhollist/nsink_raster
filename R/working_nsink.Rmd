---
title: "Draft raster methodology in R"
author:
- Jeff Hollister
- Q Kellogg
date: '2017-11-27'
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---
```{r}
#devtools::install_github("jimhester/archive")
library(here)
library(archive)
library(httr)
library(raster)
library(sp)
library(rgdal)
library(tidyverse)
library(sf)
library(FedData)
```
This is a working script to be used to figure out the raster methodology for
N-Sink.  It will be messy.

# Step 0: Get Data

Eventually front-load data collection, for now do it by task.

# Step 1: Generate flow path from user specified location

## Data
Grab flow direction and 12 Digist HUSCS from NHD Plus

```{r}
# Grab data if doesn't exist locally
if(!file.exists(here("data/nhdplus_ne_fdr.7z"))){
  fdr_url <- "http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NHDPlusNE/NHDPlusV21_NE_01_01a_FdrFac_01.7z"
  httr::GET(fdr_url, httr::write_disk(path = here("data/nhdplus_ne_fdr.7z")),progress())
  archive_extract(here("data/nhdplus_ne_fdr.7z"), here("data"))
}
if(!file.exists(here("data/nhdplus_ne_huc12.7z"))){
  huc12_url <- "http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NHDPlusNE/NHDPlusV21_NE_01_WBDSnapshot_03.7z"
  httr::GET(huc12_url, httr::write_disk(here("data/nhdplus_ne_huc12.7z")), httr::progress())
  archive_extract(here("data/nhdplus_ne_huc12.7z"), here("data"))
}
```

NHDPlus available via two-digit HUCS, for individual applications need to pare down to HUC 12 (or 10).

```{r}
fdr_ne <- raster(here("data/NHDPlusNE/NHDPlus01/NHDPlusFdrFac01a/fdr/"))
huc12_ne <- st_read(here("data/NHDPlusNE/NHDPlus01/WBDSnapshot/WBD/WBD_Subwatershed.shp")) %>% st_transform(projection(fdr_ne))
niantic_huc <- huc12_ne %>%
  filter(HU_12_NAME == "Niantic River") 
niantic_fdr <- crop(fdr_ne, as(niantic_huc,"Spatial"))
```

## Calculate the flow path of interest

This can all be done direclty in r with `raster::flowPath()`

```{r}
plot(as(niantic_huc, "Spatial"))
#loc <- unlist(locator(1)) can use this for interactive
loc <- c(1950005,2295977)
example_fp <- flowPath(niantic_fdr, loc)
example_fp_xy <- xyFromCell(niantic_fdr, example_fp)
plot(niantic_fdr)
plot(niantic_huc, add = T)
lines(example_fp_xy)
```

# Step 2: Summarize land, stream, and lake removal 

land removal is a constant made up of pixels that are vegetated Hydric Soils
Combination of hydric soils from SSURGO and Vegetated land cover from NLCD
Figuring this layer(s) out will be the most work.

## Data

### soils:  https://github.com/ncss-tech and soilDB
Soils are complicated...

- https://gdg.sc.egov.usda.gov/GDGHome_DirectDownLoad.aspx
- Can download by state - gives gridded mukey(?)
  - https://nrcs.app.box.com/v/soils/folder/23623124719
  - This is on box.com.  Need to figure way to download from R, but it's big per state.  
- Get hdyric data (yes no) from https://www.nrcs.usda.gov/Internet/FSE_DOCUMENTS/nrcseprd1316619.html
  - currently have for all NE in "data/NRCS State Hydric Soils List.html"
  - need to scrape this html to get table out into a data frame.
- Need to output row and column from gSSURGO that have a match in hydric data frame.  
- Create new raster from those matching row and columns as Hydric.  all other r,c are not hydric.
- Have an example gSSURGO for CT in the data folder
- the zip is in there too.  It was a bit weird and not directly unzippable. The source data and how to extract this needs to be figured out for reproducibilities sake!
    - FedData to the rescue!  (maybe)
    
Latest thinking on this quagmire (isn't that one of the soil types?)  Finest spatial resolution available from SSURGO is the Map Unit, yet, information in associated tables is at the component.  Components are not mapped, they are more like existential pieces of map units.  So, no way to get a binary hydric/not hydric at the 30m pixel.  Instead, components have a percentage associated with them.  So for istance, a single map unit could have 5 components in it.  We don't know where in the map unit those components exist, but we do know the proportion of each within the map unit.  I am assuming that the sum of the proportion of each component should equal 1 for each map unit.  Haven't checking this with data yet.

So, the plan is to use a weighted removal.  For instance if a map unit has 3 components and 1 is not hydric and makes up 70% of the map unit, thus 30% of the map unit is hydric.  Thus any pixels in that map unit would have 24% removal (80% for hydric * 30% of that map unit being hydric).

```{r}
#re-run
ct600_ssurgo <- get_ssurgo(c("CT600"),"ct600","data/ssurgo/ct600","data/ssurgo/ct600")

niantic_ssurgo <- get_ssurgo(as(niantic_huc, "Spatial"), "niantic", "data/ssurgo", "data/ssurgo")



niantic_ssurgo_sf <- st_as_sf(niantic_ssurgo$spatial) %>%
  st_transform(projection(fdr_ne))
names(niantic_ssurgo_sf) <- str_to_lower(names(niantic_ssurgo_sf))
niantic_ssurgo_tbl <- niantic_ssurgo$tabular$component %>%
  mutate(mukey = as(mukey, "character")) %>%
  select(mukey, cokey, hydricrating, comppct.r) %>%
  group_by(mukey, hydricrating) %>%
  summarize(hydric_pct = sum(comppct.r))

niantic_hydric <- niantic_ssurgo_sf %>%
  full_join(niantic_ssurgo_tbl, by = "mukey") %>%
  filter(hydricrating == "Yes") #%>%
  #filter(hydric_pct > 50)
  
```


### NLCD:  https://www.sciencebase.gov/catalog/item/4f70a43ce4b058caae3f8db3 (and zips on S3)

Swich this to FedData as it wraps science base locales.

```{r}
url <- "https://s3-us-west-2.amazonaws.com/prd-tnm/StagedProducts/NLCD/data/2011/landcover/3x3/NLCD2011_LC_N39W072.zip"

# FedData better option
if(!file.exists(here("data/niantic_NLCD_2011_landcover.tif"))){
  niantic_nlcd <- get_nlcd(as(niantic_huc,"Spatial"), label = "niantic", extraction.dir = "data")
}
niantic_nlcd <- raster(here("data/niantic_NLCD_2011_landcover.tif"))
```

### Percent Impervious
```{r}
# FedData better option
if(!file.exists(here("data/niantic_NLCD_2011_impervious.tif"))){
  niantic_imp <- get_nlcd(as(niantic_huc,"Spatial"), dataset = "impervious", label = "niantic", extraction.dir = "data")
}
niantic_imp <- raster(here("data/niantic_NLCD_2011_impervious.tif"))
```
### Waterbodies and Streams: NHDPlus

Grab waterbody snapshot for NE from NHD Plus

```{r}
if(!file.exists(here("data/nhdplus_ne_snapshot.7z"))){
  fdr_url <- "http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NHDPlusNE/NHDPlusV21_NE_01_NHDSnapshot_04.7z"
  httr::GET(fdr_url, httr::write_disk(path = here("data/nhdplus_ne_snapshot.7z")),progress())
  archive_extract(here("data/nhdplus_ne_snapshot.7z"), here("data"))
}
```

Waterbodies are in NHDWaterbodies and flowlines are in NHDFlowlines

```{r}
ne_streams <- st_read(here("data/NHDPlusNE/NHDPlus01/NHDSnapshot/Hydrography/NHDFlowline.shp")) %>%
  st_transform(st_crs(niantic_huc)) %>%
  st_zm
niantic_streams <- ne_streams %>%
  slice(st_contains(niantic_huc, ne_streams)[[1]])
ne_waterbodies <- st_read(here("data/NHDPlusNE/NHDPlus01/NHDSnapshot/Hydrography/NHDWaterbody.shp")) %>%
  st_transform(st_crs(niantic_huc))
niantic_waterbodies <- ne_waterbodies %>%
  slice(st_contains(niantic_huc, ne_waterbodies)[[1]])
```

Velocity estimates also in NHDPlus

Vogel and EROM based.  Ask Q.

\EROMExtension\EROM_MA0001 and EROM_mm0001 (tables) for the EROM ones and
\VogelExtension\VogelFlow (table) which has Vogel Flow and Jobson Velocity.

## Combine data into Ze Super Raster

### Input Datasets 
1. Removal on land
  - Hydric soils on non-impervious surface - 80% but weighted by percent hydric soil
    - niantic_hydric - rasterize with value == 0.8*pct_hydric
```{r}
#calc per pixel removal value
niantic_hydric_sp <- niantic_hydric %>%
  mutate(n_removal = 0.8*(hydric_pct/100)) %>%
  as("Spatial")
niantic_hydric_removal <- raster::rasterize(niantic_hydric_sp,niantic_imp, 
                                            field = "n_removal")
niantic_imp_na <- niantic_imp
niantic_imp_na[niantic_imp_na>0] <- NA 
niantic_hydric_removal <- raster::mask(niantic_hydric_removal,niantic_imp_na)
```
2. Removal in Streams
  - Mean reach depth - 0.2612 * Q ^ 0.3966
    - From Kellog et al (2010) and references therein
    - Q in cubic meters per second
  - Time of travel in days
    - From TOTMA in NHDPlus (\NHDPlusAttributes\PlusFlowlineVAA)
  - Calculate removal per reach - 1 - exp(-0.0513*(mean depth^-1.319)*TOTMA)
  - Calculate per pixel removal ((reach removal/length of reach)*raster resolution)
  - rasterize with that value
3. Removal in Lakes and Ponds
  - Qnorm approach may not be needed.
  - Get residence time for each lake and pond should now be available from NHD Plus (in Years)
  - Get mean depth (in meters)
  - Removal 79.24-33.26*log10(mean depth/residence time)
    - Need to identify the outlet pixel for all lakes and ponds and assing this value to that
    - points??
    - Rasterize this. 


## Output

What does the output for this look like? Table? Flow path with removal values?  Something else?

Bare minimum is table of removal.  Per segment ideally.

Example output #1 - landcover summary table - Along a 100 m buffer

| Landcover Class | Total Area | 
|-----------------|------------|
| Developed       | XX         |
| Forested        | XX         |
| Wetland         | XX         |
| Other           | XX         |

Example output #2 - Nitrogen removal per segment (drop to integer values)

| Segement Type | Length | Percent Removal | N in | N out |
|---------------|--------|-----------------|------|-------|
| Non-hydric    | 8156   | 0               | 100  | 100   |
| Hydric        | 546    | 80              | 100  | 20    |
| Stream        | XX     | 16              | 20   | 16.8  |
| Lake/Pond     | XX     | 23              | 16.8 | 12.9  |
| Stream        | XX     | 1               | 12.9 | 11.6  |


