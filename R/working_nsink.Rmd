---
title: "Draft raster methodology in R"
author:
- Jeff Hollister
- Q Kellogg
date: '2017-11-27'
output:
  pdf_document: default
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---

# Step 1: Load up packages required for N-Sink analysis

```{r}
pkgs <- c("here","archive", "httr", "raster", "sp", "rgdal", "tidyverse", "sf",
          "FedData","foreign", "fasterize", "mapview", "quickmapr")
for(i in pkgs){
  if(i == "archive" & !i %in% installed.packages()){
    devtools::install_github("jimhester/archive")
  } else if(!i %in% installed.packages()){
    install.packages(i)
  }
}
x<-lapply(pkgs, library, character.only = TRUE)
```

# Step 2: Get required data sets

## NHD Plus

Note: Need to write function to grab for specified huc

```{r}
# Grab data if doesn't exist locally

if(!file.exists(here("data/nhdplus_ne_fdr.7z"))){
  fdr_url <- "http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NHDPlusNE/NHDPlusV21_NE_01_01a_FdrFac_01.7z"
  httr::GET(fdr_url, httr::write_disk(path = here("data/nhdplus_ne_fdr.7z")),progress())
  archive_extract(here("data/nhdplus_ne_fdr.7z"), here("data"))
}
if(!file.exists(here("data/nhdplus_ne_huc12.7z"))){
  huc12_url <- "http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NHDPlusNE/NHDPlusV21_NE_01_WBDSnapshot_03.7z"
  httr::GET(huc12_url, httr::write_disk(here("data/nhdplus_ne_huc12.7z")), httr::progress())
  archive_extract(here("data/nhdplus_ne_huc12.7z"), here("data"))
}
if(!file.exists(here("data/nhdplus_ne_attributes.7z"))){
  attr_url <- "http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NHDPlusNE/NHDPlusV21_NE_01_NHDPlusAttributes_08.7z"
  httr::GET(attr_url, httr::write_disk(here("data/nhdplus_ne_attributes.7z")), httr::progress())
  archive_extract(here("data/nhdplus_ne_attributes.7z"), here("data"))
}

if(!file.exists(here("data/nhdplus_ne_erom.7z"))){
  erom_url <- "http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NHDPlusNE/NHDPlusV21_NE_01_EROMExtension_05.7z"
  httr::GET(erom_url, httr::write_disk(here("data/nhdplus_ne_erom.7z")), httr::progress())
  archive_extract(here("data/nhdplus_ne_erom.7z"), here("data"))
}

if(!file.exists(here("data/nhdplus_ne_snapshot.7z"))){
  fdr_url <- "http://www.horizon-systems.com/NHDPlusData/NHDPlusV21/Data/NHDPlusNE/NHDPlusV21_NE_01_NHDSnapshot_04.7z"
  httr::GET(fdr_url, httr::write_disk(path = here("data/nhdplus_ne_snapshot.7z")),progress())
  archive_extract(here("data/nhdplus_ne_snapshot.7z"), here("data"))
}
fdr_ne <- raster(here("data/NHDPlusNE/NHDPlus01/NHDPlusFdrFac01a/fdr/"))
huc12_ne <- st_read(here("data/NHDPlusNE/NHDPlus01/WBDSnapshot/WBD/WBD_Subwatershed.shp")) %>% st_transform(projection(fdr_ne))

niantic_huc <- huc12_ne %>%
  filter(HU_12_NAME == "Niantic River") %>%
  rename_all(tolower)

## Create raster to set extent, projection, etc. for all conversions
empty_raster <- fasterize::raster(niantic_huc, resolution = 30)

niantic_fdr <- crop(fdr_ne, as(niantic_huc, "Spatial")) %>%
  projectRaster(empty_raster,method = "ngb") 

ne_streams <- st_read(here("data/NHDPlusNE/NHDPlus01/NHDSnapshot/Hydrography/NHDFlowline.shp")) %>%
  st_transform(st_crs(niantic_huc)) %>%
  st_zm() %>%
  rename_all(tolower) %>%
  rename(stream_comid = comid,
         lake_comid = wbareacomi)
niantic_streams <- ne_streams %>%
  slice(st_contains(niantic_huc, ne_streams)[[1]]) %>%
  st_crop(st_bbox(niantic_huc))
ne_waterbodies <- st_read(here("data/NHDPlusNE/NHDPlus01/NHDSnapshot/Hydrography/NHDWaterbody.shp")) %>%
  st_transform(st_crs(niantic_huc)) %>%
  rename_all(tolower) %>%
  rename(lake_comid = comid) %>%
  filter(ftype == "LakePond")
niantic_waterbodies <- ne_waterbodies %>%
  slice(st_contains(niantic_huc, ne_waterbodies)[[1]])
```



## NLCD Percent Impervious
```{r}
# FedData better option
if(!file.exists(here("data/niantic_NLCD_2011_impervious.tif"))){
  niantic_imp <- get_nlcd(as(niantic_huc,"Spatial"), dataset = "impervious", label = "niantic", extraction.dir = "data")
}
niantic_imp <- projectRaster(raster(here("data/niantic_NLCD_2011_impervious.tif")), empty_raster)
# Note on projectRaster - used to force raster extents to be the same...
```

## SSURGO
```{r}
# This conditional is fragile!
if(!file.exists(here("data/ssurgo/"))){
niantic_ssurgo <- get_ssurgo(as(niantic_huc, "Spatial"), "niantic", "data/ssurgo", "data/ssurgo")
}
```

# Step 3: Summarize land, stream, and lake removal 

## Land removal from hydric

```{r}
# Read in ssurgo 
niantic_ssurgo_sf <- st_read(here("data/ssurgo/niantic_SSURGO_Mapunits.shp")) %>%
  st_transform(projection(fdr_ne)) 
names(niantic_ssurgo_sf) <- str_to_lower(names(niantic_ssurgo_sf)) 
niantic_ssurgo_tbl <- read_csv(here("data/ssurgo/niantic_SSURGO_component.csv"))%>%
  mutate(mukey = as(mukey, "character")) %>%
  select(mukey, cokey, hydricrating, comppct.r) %>%
  group_by(mukey, hydricrating) %>%
  summarize(hydric_pct = sum(comppct.r))

# Convert ssurgo to hydric removal
niantic_hydric <- niantic_ssurgo_sf %>%
  mutate(mukey = as(mukey, "character")) %>%
  full_join(niantic_ssurgo_tbl, by = "mukey") %>%
  filter(hydricrating == "Yes") %>%
  mutate(n_removal = 0.8*(hydric_pct/100)) %>%
  mutate(n_removal = case_when(n_removal == 0 ~ NA_real_,
                               TRUE ~ n_removal))
niantic_hydric_removal <- fasterize::fasterize(niantic_hydric, 
                                               empty_raster,
                                               "n_removal",
                                               background = 0,
                                               fun = "max")

# Pull in impervious to mask out hydric
niantic_imp_na <- niantic_imp
niantic_imp_na[niantic_imp_na > 0] <- NA
niantic_imp_na[!is.na(niantic_imp_na)] <- 1
niantic_hydric_removal <- raster::mask(niantic_hydric_removal,niantic_imp_na)
```

# Stream removal

```{r}
# Read in external data tables
q_dat <- read.dbf(here("data/NHDPlusNE/NHDPlus01/EROMExtension/EROM_MA0001.DBF")) %>%
  select(stream_comid = ComID,q_cfs = Q0001E) %>%
  mutate(q_cms = q_cfs * 0.028316846592) %>%
  mutate(mean_reach_depth = 0.2612 * (q_cms ^ 0.3966)) %>%
  mutate_if(is.factor, as.character())

tot_dat <- read.dbf(here("data/NHDPlusNE/NHDPlus01/NHDPlusAttributes/PlusFlowlineVAA.dbf"))%>%
  rename_all(tolower) %>%
  rename(stream_comid = comid,totma = totma) %>%
  mutate_if(is.factor, as.character())

niantic_streams <- niantic_streams %>%
  mutate_if(is.factor, as.character()) %>%
  left_join(q_dat, by = c("stream_comid" = "stream_comid")) %>%
  left_join(tot_dat, by = c("stream_comid" = "stream_comid")) 

# Calc stream removal
niantic_stream_removal <- niantic_streams %>%
  filter(ftype != "ArtificialPath") %>%
  mutate(totma = case_when(totma == -9999 ~ NA_real_,
                           TRUE ~ totma)) %>%
  mutate(n_removal = (1 - exp(-0.0513 * (mean_reach_depth^-1.319) * totma))/100) %>%
  raster::rasterize(empty_raster, 
                    field = "n_removal",
                    fun = "max") 
```

# Lake removal

```{r}
nhd_lakemorpho <- read.dbf(here("data/NHDPlusNE/NHDPlus01/NHDPlusAttributes/PlusWaterbodyLakeMorphology.dbf")) %>%
  rename_all(tolower) %>%
  rename(lake_comid = comid) %>%
  mutate_if(is.factor, as.character())

nhd_lakemorpho_flowline <- read.dbf(here("data/NHDPlusNE/NHDPlus01/NHDPlusAttributes/PlusFlowlineLakeMorphology.dbf")) %>%
  rename_all(tolower) %>%
  rename(stream_comid = comid) %>%
  mutate_if(is.factor, as.character())

# Calc waterbody residence times which is sum of TOTMA per lake on Artifical 
# Flow Paths
niantic_res_time <- niantic_streams %>%
  left_join(tot_dat) %>%
  filter(lake_comid > 0,
         totma != -9999) %>%
  group_by(lake_comid) %>%
  summarize(lake_residence_time_yrs = sum(totma*0.002737851)) %>%
  ungroup()

st_geometry(niantic_res_time) <- NULL
  
# Get artifical flow path removal table NEED TO CHECK REMOVAL CALCS
niantic_lake_removal <- niantic_waterbodies %>%
  left_join(nhd_lakemorpho) %>%
  left_join(niantic_res_time) %>%
  mutate(meandused = case_when(meandused < 0 ~ NA_real_,
                               TRUE ~ meandused)) %>%
  mutate(n_removal = (79.24 - (33.26 * log10(meandused/lake_residence_time_yrs)))/100) %>%
  mutate(n_removal = case_when(n_removal < 0 ~ 0,
                               TRUE ~ n_removal)) %>%
  fasterize::fasterize(empty_raster,
                       "n_removal",
                       fun = "max") 
```

# Getting a couple of NA lakes.  Need to figure out why and what to do about it...
# Look at Q's estimates and lake and catchement area.

# Gets Drainage Area
cumulative <- read.dbf(here("/data/NHDPlusNE/NHDPlus01/NHDPlusAttributes/CumulativeArea.dbf")) %>%
  mutate_if(is.factor, as.character()) %>%
  rename_all(tolower) %>%
  rename(stream_comid = comid)
niantic_streams %>%
  left_join(cumulative) %>%
  View()

# Merge rasters

```{r}
#Need to burn in streams into hydric as hydric 30m rasterization erases most 
#streams
stream_val <- getValues(niantic_stream_removal)
stream_val[stream_val>=0] <- 0
stream_val[is.na(stream_val)] <- 1
hydric_val <- getValues(niantic_hydric_removal)
hydric_val <- hydric_val * stream_val
niantic_hydric_removal <- setValues(niantic_hydric_removal, hydric_val)


niantic_n_removal <- raster::merge(niantic_lake_removal, 
                                    niantic_stream_removal, 
                                    niantic_hydric_removal) 
niantic_n_removal <- mask(niantic_n_removal, niantic_huc)
```

```{r}
# Simple plot!
#brks <- c(0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8)
#color <- rev(RColorBrewer::brewer.pal(9,"RdYlBu"))
plot(niantic_n_removal)
plot(niantic_streams$geometry, add = T, col = "slateblue", lwd = 2)
```


## How to calc flow path stuff

## Calculate the flow path of interest

This can all be done direclty in r with `raster::flowPath()`

Issues with flowpath not following the streams exactly.  

Ideas:
1. Calc flow path
```{r}
#plot(niantic_huc$geometry)
#plot(niantic_streams$geometry, add = T)
#loc <- unlist(locator(1)) #can use this for interactive
loc <- c(1948121,2295822) 
example_fp_niantic <- flowPath(niantic_fdr, loc)
fp_n_r_v <- values(empty_raster)
fp_n_r_v[example_fp_niantic]  <- 1
fp_n_r <- setValues(empty_raster, fp_n_r_v)

x <- raster::extract(fp_n_r, niantic_streams)


example_fp_xy <- xyFromCell(empty_raster, example_fp_niantic)
fp_n_sfc <- st_sfc(st_linestring(example_fp_xy), crs = st_crs(niantic_streams))
fp_n_sf <- st_sf(geometry = fp_n_sfc)
x <- st_difference(fp_n_sf, niantic_streams)                 
```

2. Get all intersecting stream flow lines and find most upstream flow line and grab downstream flowlines.

```{r}
f_s_inter_upstream <- niantic_streams %>%
  slice(st_intersects(fp_n,niantic_streams)[[1]]) %>%
  st_crop(st_bbox(fp_n)) # %>%
  filter(hydroseq == max(hydroseq))
```


5. Get portion of flow path below stream flwolines (it happens, happens a lot)
6. Combine together in combo flowpath
7. Convert to raster.




2018-05-09
Thinking about removal more.  It is NOT necessarily a function of length and can't divide percent removal to get a per pixel removal.  No need to divide by length or pixel size.

Calculate removal per feature and rasterize with that value 
  - all hydric will be 0.8 * percent hydric
  - lakes will be total removal for that lake
  - streams will be total for that reach
  
Get vector of removal values, grab last consecutive value, cumprod it.  Example

```{r}
# removal vector is overlay of flowpath on removal raster
x<-c(0.8,0.8,0.8,0.02,0.02,0.02,0.02,0.02,0.35,0.35,0.35,0.35,0.35,0.001,0.001,0.35)
# x_last is the last consectuive instance of that value in the vector
x_last <- zoo::rollapply(x, width = 2, partial = TRUE, 
                          function(x) ifelse(x[1]==x[2],0, x[1]))
x_last <- ifelse(is.na(x_last),x[length(x)],x_last)
x_last_removal <- 1-x_last
# Add starting load and cumprod it
cumprod(c(100,x_last_removal))
```

Need to query a raster stack with layer of removal, polygon id, and layer type.  Will facilitate 
- output of removal per type (eg hydric, lake, stream)
- checking to make sure that consecutive unique features that have same removal don't get lost.  Use feature ID on sliding window, not removal.  


## Output

What does the output for this look like? Table? Flow path with removal values?  Something else?

Bare minimum is table of removal.  Per segment ideally.

Example output #1 - landcover summary table - Along a 100 m buffer

| Landcover Class | Total Area | 
|-----------------|------------|
| Developed       | XX         |
| Forested        | XX         |
| Wetland         | XX         |
| Other           | XX         |

Example output #2 - Nitrogen removal per segment (drop to integer values)

| Segement Type | Length | Percent Removal | N in | N out |
|---------------|--------|-----------------|------|-------|
| Non-hydric    | 8156   | 0               | 100  | 100   |
| Hydric        | 546    | 80              | 100  | 20    |
| Stream        | XX     | 16              | 20   | 16.8  |
| Lake/Pond     | XX     | 23              | 16.8 | 12.9  |
| Stream        | XX     | 1               | 12.9 | 11.6  |



